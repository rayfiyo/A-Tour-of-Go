// 前回 11 で、インターフェースは、動的型 と 動的値 のタプルと表現できると説明した
//
// 1. 動的型 = nil, 動的値 = nil の場合（インターフェースが完全にnilの場合）、
// メソッド呼び出し（例: i.M()）は、呼び出された時点でパニックになる
//
// 2. 動的型 = ポインタ型（例: *T）, 動的値 = nil の場合、
// そのインターフェース自体は 非nil であることに注意する
//
// このとき、レシーバは nil をとるから、メソッドを呼び出せる
// （他の言語と比較すると、Go は null ポインター例外 にはならない）
// （ただし、レシーバをデリファレンスするとパニックする（例: _ = t）
//
// だから、メソッドの実装が（レシーバの具体型が） nil レシーバを契約として許容する場合は
// そのメソッドの先頭部分で if 文を使って処理する（実務的）
//
// また、この場合で動的値 nil を正しく判定したい場合は型アサーションを使う必要がある
// if ptr, ok := t.(*T); ok {
//     if ptr == nil {
// 	   }
// }

// I 抽象型: メソッド M の集合
// T 構造体: S 文字列型をフィールドにもつ
// メソッドMの実装: t *T型をレシーバに持つ
//     I 抽象型は nil を許容する
//     t.S の値を標準出力する
// 主な処理:
//     1. i I型に、*T 型の nil 値 t を代入し、describe()し、メソッドMを実行する
//     2. i I型に、*T 型の "hello" 値を代入し、 1 と同様に処理する
// describe関数: i I型を引数にとり、その値と型を標準出力する

package main

import (
	"fmt"
)

type I interface {
	M()
}

type T struct {
	S string
}

func (t *T) M() {
	if t == nil {
		fmt.Println("<nil>")
		return
	}
	fmt.Println(t.S)
}

func main() {
	var i I

	var t *T // 型付き nil はここから来た（別の例: t := hoge()）
	i = t
	// 上は `var i I = (*T)(nil)` とも表現できるが、
	// 中間変数 t を用いた方が どこから型付き nil が来たかわかりやすい
	describe(i)
	i.M()

	i = &T{"hello"}
	describe(i)
	i.M()
}

func describe(i I) {
	fmt.Printf("(%v, %T)\n", i, i)
}
