// 型アサーション: インターフェース値が保持している具体的な値にアクセスする方法
//   保持している値を第一、アサーションの成否を第二の返り値に持つ
//
// t := i.(T)
//   この文は、インターフェース値 i が動的型として T を保有していることを主張し、
//   T の値を t に代入する
//   なお、i が T を保持していない場合、パニックになる
//
// t, ok := i.(T)
//   この文は、インターフェース値 i が、特定の型 T を保持しているか調べたい場合に用いる
//   i が T を保持していれば ok は true となる
//   マップから値を読む構文 （例: i, ok := m["route"]） と似ている

// 主な処理:
//   1. i 抽象型に "hello" を代入する
//   2. 第一引数のみの型アサーションを用い、返り値を標準出力をする
//   3. 第二引数まである型アサーションを用い、返り値を標準出力する
//   4. 不適切な型アサーションを行い、返り値を標準出力する
//   5. 不適切な型アサーションを行い、パニックを起こし、標準出力する

package main

import (
	"fmt"
)

func main() {
	var i any = "hello"
	// var i interface{} = "hello"

	s := i.(string)
	fmt.Println(s)

	s, ok := i.(string) // ok が新出なので := で良い
	fmt.Println(s, ok)

	f, ok := i.(float64)
	fmt.Println(f, ok)

	f = i.(float64)
	fmt.Println(f)
}
